"""
TreatmentFlow
Constraint Optimization: Hospital Bed Assignment - Greedy Approach

By Adam Neto and Emese Elkind
Started: February 2025

CISC 352: Artificial Intelligence
"""

from HospitalClasses import HospitalRecords
from HospitalClasses import print_time

# This file is an experimental application of our bed assignment system using the greedy paradigm

"""
Information we are working with:
- list of patients
    - includes arrival time 
    - includes patient priority (generated by DL file)

Goal of solution:
- optimize bed assignment based on priority and arrival
    - minimize the wait times of patients, with higher-priority patients scaled such 
        that their wait times are more punishing if long (multiply wait times by patient cost)

Summary of approach:
- sort list of patients by arrival time (OR create running list that trickles in by arrival time?)
    - sort patients with identical arrival times by priority
        - assign highest priority patients to beds with greedy methods, such that next available bed
            is assigned to next highest priority patient
            - will need a running list of patients to-be-served
                - if a new patient arrives after current patients with a higher priority,
                    they will be assigned a bed first
                        POTENTIAL ISSUE: how to avoid low-priority starvation
"""

# greedy-based hospital simulator class (for testing / showcase)
class Scheduler:
    def __init__(self, Hospital) -> None:
        if not type(Hospital) == HospitalRecords:
            raise TypeError("The Hospital to be scheduled not type Hospital")
        
        self.Hospital = Hospital

    # object oriented hospital simulator
    def run_hospital(self, printing):

        # 'printing' is boolean input to determine whether updating print happens
        for minute in range(1440):
            change_made = False

            for patient in self.Hospital.serving:
                if minute - patient.service_start >= patient.service_time:
                    self.Hospital.discharge_patient(patient)
                    change_made = True
                    # print(f"Discharging {patient.id}")

            for patient in self.Hospital.unserved:
                # print(patient.arrival_time)
                if patient.arrival_time <= minute:
                    if self.Hospital.beds_available:
                        self.Hospital.serve_patient(patient)
                        patient.service_start = minute
                        change_made = True
                        # print(f"Serving {patient.id}")
            
            # print current arrangement
            if change_made and printing:
                self.print_arrangement(minute)
                queue = ""
                for patient in self.Hospital.unserved:
                    if patient.arrival_time <= minute:
                        queue = queue + f" {patient.id}:{patient.priority}"
                print(f"Queue: {queue}")

    def waiting_times(self):

        waiting_times_list = []
        for patient in self.Hospital.patient_list:
            my_waiting_time = patient.get_waiting_time()
            
            if my_waiting_time != 0:
                waiting_times_index = 0
                while (waiting_times_index < len(waiting_times_list)) and (my_waiting_time < waiting_times_list[waiting_times_index].get_waiting_time()):
                    waiting_times_index += 1
                
                waiting_times_list.insert(waiting_times_index, patient)

        print("\n--Waiting Times--")
        for patient in waiting_times_list:
            print(f"id: {patient.id}, pri: {patient.priority}, wait: {patient.get_waiting_time()}")
                    
    def objective(self):

        objective = 0
        for patient in self.Hospital.patient_list:
            my_waiting_time = patient.get_waiting_time()

            if my_waiting_time >= 0:
                # weigh wait times by priority to match MIP approach
                objective += patient.priority * my_waiting_time
            else:
                # penalty tracker to match MIP approach
                objective += patient.priority * 1440

        return objective

    def print_arrangement(self, time):

        WIDTH = 10

        bed_print = []
        row = []

        for bed in self.Hospital.beds:
            if bed.id % WIDTH == 0:
                if bed.id != 0:
                    bed_print.append(row)
                row = []
                
            if bed.occupied:
                row.append(f"{bed.occupant.id}:{bed.occupant.priority}")
            else:
                row.append("   ")

        bed_print.append(row)

        # printing array
        print(f"\n--HOSPITAL AT {print_time(time)}--")
        for this_row in bed_print:
            print(this_row)


# # testing Greedy so many times
# pat_denoms = [5, 10, 25, 50, 100, 250, 500]
# bed_denoms = [5, 10, 25, 50, 100]

# info = [[0 for p in range(len(pat_denoms))] for b in range(len(bed_denoms))]
# obj_info = [[0 for p in range(len(pat_denoms))] for b in range(len(bed_denoms))]
# NUM_OBS = 100

# for b in range(len(bed_denoms)):

#     row = ""

#     for p in range(len(pat_denoms)):

#         total_wait_times = 0
#         total_unserved = 0
#         total_obj = 0

#         # randomized hospitals
#         for i in range(NUM_OBS):

#             # build and run randomized hospital
#             hospital = HospitalRecords(bed_denoms[b])
#             scheduler = Scheduler(hospital)
#             hospital.gen_patient_list(pat_denoms[p])
#             scheduler.run_hospital(False)

#             total_obj += scheduler.objective()

#             for patient in hospital.patient_list:
#                 if patient.get_waiting_time() < 0:
#                     total_unserved += 1
#                 else:
#                     total_wait_times += patient.get_waiting_time()
        
#         info[b][p] = f"[{int((total_wait_times / NUM_OBS / pat_denoms[p]))}, {int(total_unserved / NUM_OBS)}]"
#         obj_info[b][p] = f"[{int(total_obj / NUM_OBS)}]"

#         row += info[b][p]
    
#     print(row)


# # printing obj info
# print("\nObjective info")
# for b in range(len(bed_denoms)):
#     row = ""
#     for p in range(len(pat_denoms)):
#         row += obj_info[b][p]
#     print(row)
